%%
% 结论
% 结论是毕业论文的总结，是整篇论文的归宿，应精炼、准确、完整。结论应着重阐述自己的创造性成果及其在本研究领域中的意义、作用，还可进一步提出需要讨论的问题和建议。
% modifyer: 黄俊杰(huangjj27, 349373001dc@gmail.com)
% update date: 2017-04-13
%%

\chapter{总结与展望}
\section{总结}
本文提以蛇形机器人自适应控制为研究的主要内容，提出了一种基于经验学习的机器人自适应控制框架。 首先本文介绍了国内外蛇形机器人自适应控制和自动化运动的研究现状，然后介绍了蛇形机器人常用的设计结构和运动步态。本文实验的环境是V-REP仿真平台，在该平台上对正交结构的蛇形机器人和管道环境进行建模，通过V-REP提供的应用程序接口将本文算法运用在蛇形机器人的运动上。本文将机器人实时的Z轴速度作为反馈信号，并采用回归分析来让机器人自主调整运动步态。通过对训练数据进行聚类优化了运行时工作的计算耗时，并通过计算每个控制参数的熵方差来挑选最敏感控制参数，从而实现将一个多元回归分析问题转换为一个一元回归分析问题。实验结果表明本文提出方案是有效的，并且取得较好的效果。 

本文的研究内容和研究成果如下：
\begin{itemize}
	\item 利用在蛇形机器人的关节模块上集成角度传感器，加速度计，陀螺仪等实时获取蛇形机器人的运动姿态，收集必要的实验数据，保证了算法的及时性。
	\item 通过使用k-means++聚类算法对训练数据进行聚类，在运行时算法时实现了一定程度上减少了回归分析的数据量，优化了算法的计算效率。
	\item 引入了熵方差的衡量标准，有效衡量了每个控制参数对步态的影响程度，从而便于挑选最敏感参数，因此在回归分析部分实现了多元回归分析简化成一元回归分析。
	\item 在爬杆模型中，本文在复杂的变杆模型和多种直径的直杆模型进行多组对照实验。从实验结果中可以证明本文提出的蛇形机器人快速自适应爬杆运动的算法是正确有效的。根据实时获得的位姿信息，蛇形机器人通过快速地回归分析自适应地调整步态参数。
\end{itemize}

\section{展望}
如本文上面所提到的，本文实现的方法的思路不仅可以用于本实验中的杆攀爬运动中，还可以用于机器人的其他运动环境或应用中。对于该算法只要给出足够的训练数据和清晰的运动目的是可以适应其他相应的场景，如无人驾驶车辆的自适应运动，蛇形机器人在粗糙地面的运动和模拟PID控制。但是这些情况还没有通过实验验证。本文实现的基于经验学习的应用在关节正交结构的蛇形机器人上的控制算法还有一些不足之处，如下所示：
\begin{enumerate}
	\item 本文实现的自适应控制算法未能运用在真实蛇形机器人上。在真实的蛇形机器人上需要在真实的蛇形机器人上安装足够多的的传感器以及通过信号收发模块来收集运动数据。在真实蛇形机器人上的成功应用是本文提出的自适应控制的最终目的。
	\item 本文提出的自适应控制算法实验中只对蛇形机器人在复杂的杆中运动进行测试实验，运动步态还不够复杂，运动环境也不够复杂。更复杂的运动环境和步态还有待验证。
	\item 本文提出的自适应控制算法实验中，蛇形机器人只是在纵向向上的运动中可以自适应调节步态。事实上蛇形机器人在横向或者纵向存在向上运动趋势的运动中都能够在本文提出的算法控制下顺利运动，但是对于有纵向向下运动趋势的运动蛇形机器人无法顺利进行。这是之后算法改进需要考虑的一点。
	\item 我们可以通过拓展蛇形机器人的经验特征值，例如引入摩擦力，倾斜度等特征因子，来让蛇形机器人可以在更多更复杂的环境中实现自适应的运动。
\end{enumerate}

本次蛇形机器人的自适应运动控制方法是一次成功的尝试，日后可以在更多相关的研究进展中不断完善改进我们的算法甚至可以将我们的算法思想应用到多种实验情况中，如自动驾驶的控制等等。

%\begin{algorithm}[h]
%\KwIn{data——一组观测数据集 \\ \qquad \quad 
%	model——一个拟合数据点的模型\\ \qquad \quad 
%	n——用于拟合模型的数据最小值\\ \qquad \quad 
%	k——算法中的最大迭代次数\\ \qquad \quad 
%	t——用于决定数据点拟合模型时机的阈值\\ \qquad \quad 
%	d——断言模型非常适合数据所需的关闭数据值的数量}
%\KwOut{benefit——最拟合数据的模型参数（没有求解得到一个好的模型是为空）}
%\Begin{iterations = 0\\
%bestfit = nul\\
%besterr = something really large}
%\While{iterations < k}{
%	maybeinliers = 从数据中随机选取的n个样本
%	maybemodel = 拟合于maybeinliers的模型参数
%	alsoinliers = 空数据集\\
%	\ForAll{在数据集data中而不再maybeinliers中的数据点}{
%		\If{数据点拟合maybemodel同时误差小于阈值t}{
%			将数据点加入到alsoinliers中	
%		}
%	}
%	\If{alsoinliers中的其他元素的数量大于d}{
%		bettermodel = 拟合maybeinliers和alsoinliers中所有数据点的模型参数
%		thiserr = 衡量模型拟合数据点的程度
%		\If{thiserr < besterr}{
%			bestfit = bettermodel
%			besterr = thiserr
%		}
%	}
%	iterations = iterations + 1
%}
%\Return{benefit}
%\caption{RANSAC算法}
%\label{algo:ransac}
%\end{algorithm}

%\begin{algorithm}[h]
%\Begin{
%	把原图做一次Canny边缘检测，得到边缘检测的二值图\\
%	对原始图像执行一次Sobel算子，计算出所有像素的邻域梯度值\\
%	\ForAll{N(a,b)}{N(a,b)=0}
%	\ForEach{Canny边缘二值图中的所有非零像素点}{
%		沿着梯度方向画线，将线段经过的所有累加器中的点(a,b)的N(a,b)+=1
%	}
%	统计排序N(a,b)，得到可能的圆心
%}
%\caption{霍夫变换检测圆——估计圆心算法}
%\label{algo:houghcircle1}
%\end{algorithm}
%
%\begin{algorithm}[h]
%	\Begin{
%		\ForAll{Canny图中非0点}{计算距离圆心的距离}
%		距离从小到大排序，根据阈值，选取合适的可能半径\\
%		初始化半径空间r,N(r)=0\\
%		\ForEach{Canny图中的非0点}{
%			对于点所满足的半径r，N(r)+=1
%		}
%		统计得到可能的半径值
%	}
%	\caption{霍夫变换检测圆——针对某一个圆心a,b的半径估计算法}
%	\label{algo:houghcircle2}
%\end{algorithm}